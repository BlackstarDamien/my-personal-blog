name: My Personal Blog

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest

    # Docker-in-Docker service used by testcontainers to create browser containers
    services:
      docker:
        image: docker:24-dind
        ports:
          - 2375:2375
        env:
          DOCKER_TLS_CERTDIR: ""
        options: >-
          --name job-dind --privileged

    env:
      # point testcontainers to reach the runner's django server via host.docker.internal
      TEST_HOST: "host.docker.internal"
      TEST_PORT: "8001"
      TESTCONTAINERS_HOST_OVERRIDE: "host.docker.internal"
      # allow Ryuk (reaper) to run; we also explicitly remove leftover testcontainers containers below
      TESTCONTAINERS_RYUK_DISABLED: "false"
      # instruct docker client to use the dind service
      DOCKER_HOST: "tcp://localhost:2375"
      DOCKER_TLS_VERIFY: "0"

    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Wait for Docker daemon
      run: |
        # wait up to 60s for the dind docker daemon to be ready
        for i in $(seq 1 60); do
          docker version >/dev/null 2>&1 && break || sleep 1
        done
        docker info

    - name: Cleanup leftover testcontainers containers (safe)
      run: |
        # remove stale testcontainers/ryuk containers to avoid name conflicts
        docker ps -a --filter "name=testcontainers" -q | xargs -r docker rm -f || true

    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.x'

    - name: Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run migrations
      run: |
        make migrate

    - name: Collect static files
      run: |
        make generate-static

    - name: Start Django dev server in background
      run: |
        # Start the dev server bound to 0.0.0.0 so containers can reach it.
        nohup python manage.py runserver 0.0.0.0:8001 > server.log 2>&1 &
        echo $! > /tmp/django.pid
        # wait for server to accept connections
        for i in $(seq 1 30); do
          curl -sS http://localhost:8001/ >/dev/null && break || sleep 1
        done
        echo "Django started (pid $(cat /tmp/django.pid))"
      shell: bash

    - name: Debug show docker containers (post-start)
      run: docker ps -a

    - name: Run e2e tests
      run: |
        # run e2e tests which will use testcontainers to spin up browser containers
        make e2e
      env:
        # also export these just for the run step (redundant but explicit)
        TEST_HOST: "host.docker.internal"
        TEST_PORT: "8001"
        TESTCONTAINERS_HOST_OVERRIDE: "host.docker.internal"
        DOCKER_HOST: "tcp://localhost:2375"
        DOCKER_TLS_VERIFY: "0"

    - name: Run integration tests
      run: |
        make integration

    - name: Run unit tests
      run: |
        make unit

    - name: Stop Django server
      if: always()
      run: |
        if [ -f /tmp/django.pid ]; then
          kill $(cat /tmp/django.pid) || true
          rm -f /tmp/django.pid
        fi
        tail -n +1 server.log || true